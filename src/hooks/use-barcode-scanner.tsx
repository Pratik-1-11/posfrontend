import { useEffect, useCallback, useRef } from 'react';
interface BarcodeScannerOptions { onScan: (barcode: string) => void; onError?: (error: string) => void; minLength?: number; maxLength?: number; timeBeforeAccept?: number; enabled?: boolean; }
export const useBarcodeScanner = ({ onScan, onError, minLength = 3, maxLength = 20, timeBeforeAccept = 100, enabled = true }: BarcodeScannerOptions) => {
  const barcodeBuffer = useRef<string>(''); const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null); const lastKeyTime = useRef<number>(0);
  const handleKeyPress = useCallback((event: KeyboardEvent) => { if (!enabled) return; const currentTime = Date.now(); const timeDiff = currentTime - lastKeyTime.current; if (timeDiff > timeBeforeAccept && barcodeBuffer.current.length > 0) { barcodeBuffer.current = ''; } lastKeyTime.current = currentTime; if (event.key === 'Enter' && barcodeBuffer.current.length > 0) { event.preventDefault(); const barcode = barcodeBuffer.current; barcodeBuffer.current = ''; if (barcode.length < minLength) { onError?.(`Barcode too short`); return; } if (barcode.length > maxLength) { onError?.(`Barcode too long`); return; } onScan(barcode); return; } if (event.key.length > 1 && event.key !== 'Enter') { return; } const target = event.target as HTMLElement; const isInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA'; const isSearchInput = target.getAttribute('type') === 'search'; if (isInput && !isSearchInput) { return; } if (event.key.length === 1) { barcodeBuffer.current += event.key; if (timeoutRef.current) { clearTimeout(timeoutRef.current); } timeoutRef.current = setTimeout(() => { barcodeBuffer.current = ''; }, timeBeforeAccept * 2); } }, [enabled, minLength, maxLength, timeBeforeAccept, onScan, onError]);
  useEffect(() => { if (!enabled) return; window.addEventListener('keydown', handleKeyPress); return () => { window.removeEventListener('keydown', handleKeyPress); if (timeoutRef.current) { clearTimeout(timeoutRef.current); } }; }, [enabled, handleKeyPress]);
  return { isEnabled: enabled };
};
